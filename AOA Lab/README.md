<!-- =========================================================================================
                                     HEADER SECTION
     ========================================================================================= -->
<div align="center">

  <!-- Title -->
  # Analysis of Algorithm Lab

  <!-- Subtitle -->
  ### CSL401 ¬∑ Semester IV ¬∑ Computer Engineering

  <!-- Badges -->
  [![Curated by](https://img.shields.io/badge/Curated%20by-Amey%20Thakur-blue.svg)](https://github.com/Amey-Thakur)
  [![Programs](https://img.shields.io/badge/Programs-5-yellowgreen.svg)](#quick-navigation)
  [![Language](https://img.shields.io/badge/Language-C-blueviolet.svg)](.)
  [![Lab Manual](https://img.shields.io/badge/Lab%20Manual-Available-brightgreen.svg)](PRACTICAL%20LAB.pdf)

  <!-- Short Description -->
  **A comprehensive collection of 5 experiments covering fundamental algorithm design techniques with detailed comments, proper documentation, and industry-standard coding practices.**

  ---

  <!-- Navigation Links -->
  **[Experiment 1](#experiment-1-sorting-algorithms-2-programs)** &nbsp;¬∑&nbsp; **[Experiment 2](#experiment-2-divide-and-conquer---search-1-program)** &nbsp;¬∑&nbsp; **[Experiment 3](#experiment-3-divide-and-conquer---sort-1-program)** &nbsp;¬∑&nbsp; **[Experiment 4](#experiment-4-dynamic-programming-1-program)** &nbsp;¬∑&nbsp; **[Experiment 5](#experiment-5-graph-algorithms-1-program)** &nbsp;¬∑&nbsp; **[How to Use](#how-to-use)** &nbsp;¬∑&nbsp; **[Learning Path](#learning-path)**

</div>

---

> [!TIP]
> **Algorithm Visualization**: Always trace your algorithm's execution flow on paper before coding. Draw recursion trees for divide-and-conquer approaches, create tables for dynamic programming solutions, and visualize array/pointer states at each step. Dry running with small test cases and manually calculating time/space complexity is the most effective way to master algorithm design paradigms and optimize computational efficiency.

> [!WARNING]
> **Complexity Constraints**: Using a brute-force approach (O(n¬≤)) for large inputs (n > 10‚Åµ) will result in **Time Limit Exceeded (TLE)** errors. Always analyze the constraints before implementation and optimize your logic to use efficient paradigms (Divide & Conquer or Dynamic Programming) where applicable to meet execution limits.

---

<!-- =========================================================================================
                                     EXPERIMENT 1
     ========================================================================================= -->
## Experiment 1: Sorting Algorithms (2 Programs)

| # | Program | Algorithm | Time Complexity |
|:---|:---|:---|:---|
| 1 | [Insertion_Sort.c](Experiment-1/Insertion_Sort.c) | Insertion Sort | O(n¬≤) |
| 2 | [Selection_Sort.c](Experiment-1/Selection_Sort.c) | Selection Sort | O(n¬≤) |

---

<!-- =========================================================================================
                                     EXPERIMENT 2
     ========================================================================================= -->
## Experiment 2: Divide and Conquer - Search (1 Program)

| # | Program | Algorithm | Time Complexity |
|:---|:---|:---|:---|
| 1 | [Binary_Search.c](Experiment-2/Binary_Search.c) | Recursive Binary Search | O(log n) |

---

<!-- =========================================================================================
                                     EXPERIMENT 3
     ========================================================================================= -->
## Experiment 3: Divide and Conquer - Sort (1 Program)

| # | Program | Algorithm | Time Complexity |
|:---|:---|:---|:---|
| 1 | [Merge_Sort.c](Experiment-3/Merge_Sort.c) | Merge Sort | O(n log n) |

---

<!-- =========================================================================================
                                     EXPERIMENT 4
     ========================================================================================= -->
## Experiment 4: Dynamic Programming (1 Program)

| # | Program | Algorithm | Time Complexity |
|:---|:---|:---|:---|
| 1 | [Longest_Common_Subsequence.c](Experiment-4/Longest_Common_Subsequence.c) | LCS (Dynamic Programming) | O(m√ón) |

---

<!-- =========================================================================================
                                     EXPERIMENT 5
     ========================================================================================= -->
## Experiment 5: Graph Algorithms (1 Program)

| # | Program | Algorithm | Time Complexity |
|:---|:---|:---|:---|
| 1 | [All_Pair_Shortest_Path.c](Experiment-5/All_Pair_Shortest_Path.c) | Floyd-Warshall | O(n¬≥) |

---

<!-- =========================================================================================
                                     HOW TO USE SECTION
     ========================================================================================= -->
## How to Use

1. **Navigate** to the desired experiment folder
2. **Open** the `.c` file
3. **Compile** using: `gcc filename.c -o output`
4. **Run** using: `./output` (Linux/Mac) or `output.exe` (Windows)

Example:
```bash
cd "Experiment-1"
gcc Insertion_Sort.c -o Insertion_Sort
./Insertion_Sort
```

---

<!-- =========================================================================================
                                     LEARNING PATH SECTION
     ========================================================================================= -->
## Learning Path

**Beginner Level:**
- Start with Experiment 1 (Sorting Algorithms)
- Understand basic algorithm analysis with insertion and selection sort

**Intermediate Level:**
- Explore Experiment 2 & 3 (Divide and Conquer)
- Learn recursive problem-solving with binary search and merge sort

**Advanced Level:**
- Study Experiment 4 (Dynamic Programming)
- Understand optimal substructure with LCS
- Analyze Experiment 5 (Graph Algorithms)
- Master all-pairs shortest path with Floyd-Warshall

---

<!-- =========================================================================================
                                     FOOTER SECTION
     ========================================================================================= -->
<div align="center">

  <!-- Footer Navigation -->
  **[Back to Top](#analysis-of-algorithm-lab)**

  **[Experiment 1](#experiment-1-sorting-algorithms-2-programs)** &nbsp;¬∑&nbsp; **[Experiment 2](#experiment-2-divide-and-conquer---search-1-program)** &nbsp;¬∑&nbsp; **[Experiment 3](#experiment-3-divide-and-conquer---sort-1-program)** &nbsp;¬∑&nbsp; **[Experiment 4](#experiment-4-dynamic-programming-1-program)** &nbsp;¬∑&nbsp; **[Experiment 5](#experiment-5-graph-algorithms-1-program)** &nbsp;¬∑&nbsp; **[How to Use](#how-to-use)** &nbsp;¬∑&nbsp; **[Learning Path](#learning-path)**

  <br>

  **[üè† Back to Main Repository](../)**

  ---

  ### [Analysis of Algorithm and Analysis of Algorithm Lab](https://github.com/Amey-Thakur/ANALYSIS-OF-ALGORITHM-AND-ANALYSIS-OF-ALGORITHM-LAB)

  **CSC402 & CSL401 ¬∑ Semester IV ¬∑ Computer Engineering**

  *University of Mumbai ¬∑ Curated by [Amey Thakur](https://github.com/Amey-Thakur)*

</div>
